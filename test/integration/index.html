<!doctype html>
<html>
    <head>
        <title>Logux Status</title>
    </head>
    <body>
        <img id="logo" width="100" height="100" src="https://cdn.rawgit.com/logux/logux/master/logo.svg" />
        <h1>Demo: Logux Status</h1>
        <p>
            <a href="https://github.com/logux" target="_blank">Logux</a> is a client-server communication protocol. It synchronizes actions between clients and server logs.
            <br />
            <a href="https://github.com/logux/logux-status" target="_blank">Logux Status</a> provides UX best practices to report Logux synchronization status to user.
        </p>
        <p>
            This page tests Logux Status features:
        </p>
        <ul>
            <li><strong>attention</strong> — highlight tab on synchronization error to notify user</li>
            <li><strong>confirm</strong> — show confirm popup, when user close tab with non-synchronized actions</li>
            <li><strong>favicon</strong> — change favicon to show synchronization status</li>
            <li><strong>log</strong> — display Logux events in browser console</li>
        </ul>
        <h2>Demo</h2>
        <p>
            <label>
                <input type="checkbox" id="toggle-connection" />
                Toggle connection between client and server.
                <br />
                <small>
                    Tests:
                    <strong>favicon</strong>,
                    <strong>log</strong>
                </small>
            </label>
        </p>
        <p>
            <button id="send-client-error">Error after 3 seconds</button>
            Click to emulate client error
            <br />
            <small>
                Tests:
                <strong>attention</strong>,
                <strong>favicon</strong>,
                <strong>log</strong>
            </small>
        </p>
        <p>
            <button id="send-server-error">Send server error after 3 seconds</button>
            Click to emulate server error
            <br />
            <small>
                Tests:
                <strong>attention</strong>,
                <strong>favicon</strong>,
                <strong>log</strong>
            </small>
        </p>
        <p>
            <button id="add-action">Add action to log</button>
            Click to add test action to log
            <br />
            <small>
                Tests:
                <strong>confirm</strong>,
                <strong>log</strong>
            </small>
        </p>
        <p>
            <button id="clean-actions">Clean actions</button>
            Click to clean log
            <br />
            <small>
                Tests:
                <strong>log</strong>
            </small>
        </p>
    <script>/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.l = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };

/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};

/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};

/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 38);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

/**
 * Interface for event subscription.
 *
 * @example
 * class Ticker {
 *   constructor() {
 *     this.emitter = new NanoEvents()
 *   }
 *   on() {
 *     return this.emitter.on.apply(this.events, arguments)
 *   }
 *   once() {
 *     return this.emitter.once.apply(this.events, arguments)
 *   }
 *   tick() {
 *     this.emitter.emit('tick')
 *   }
 * }
 *
 * @class
 */
module.exports = function NanoEvents () {
  /**
   * Event names in keys and arrays with listeners in values.
   * @type {object}
   *
   * @example
   * Object.keys(ee.events)
   */
  this.events = { }
}

function add (events, event, cb) {
  if (typeof cb !== 'function') {
    throw new Error('Expected event listener to be a function')
  }

  var added = true
  var l = { fn: cb }

  l.rm = function () {
    if (!added) return
    added = false
    var list = events[event]
    if (list.length > 1) {
      list.splice(list.indexOf(l), 1)
    } else {
      delete events[event]
    }
  }

  if (events[event]) {
    events[event].push(l)
  } else {
    events[event] = [l]
  }
  return l
}

module.exports.prototype = {

  /**
   * Add a listener for a given event.
   *
   * @param {string} event The event name.
   * @param {function} cb The listener function.
   *
   * @return {function} Unbind listener from event.
   *
   * @example
   * const unbind = ee.on('tick', (tickType, tickDuration) => {
   *   count += 1
   * })
   *
   * disable () {
   *   unbind()
   * }
   */
  on: function on (event, cb) {
    return add(this.events, event, cb).rm
  },

  /**
   * Add a one-time listener for a given event.
   *
   * @param {string} event The event name.
   * @param {function} cb The listener function.
   *
   * @return {function} Unbind listener from event.
   *
   * @example
   * const unbind = ee.once('tick', (tickType, tickDuration) => {
   *   works = true
   * })
   */
  once: function once (event, cb) {
    var l = add(this.events, event, cb)
    l.once = true
    return l.rm
  },

  /**
   * Calls each of the listeners registered for a given event.
   *
   * @param {string} event The event name.
   * @param {...*} arguments The arguments for listeners.
   *
   * @returns {boolean} `true` if the event had listeners, else `false`.
   *
   * @example
   * ee.emit('tick', tickType, tickDuration)
   */
  emit: function emit (event) {
    var list = this.events[event]
    if (!list || !list.length) return false

    var copy = list.slice(0)

    var args = new Array(arguments.length - 1)
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i]
    }

    for (i = 0; i < copy.length; i++) {
      var l = copy[i]
      l.fn.apply(this, args)
      if (l.once) l.rm()
    }

    return true
  }

}


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var randomFromSeed = __webpack_require__(36);

var ORIGINAL = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-';
var alphabet;
var previousSeed;

var shuffled;

function reset() {
    shuffled = false;
}

function setCharacters(_alphabet_) {
    if (!_alphabet_) {
        if (alphabet !== ORIGINAL) {
            alphabet = ORIGINAL;
            reset();
        }
        return;
    }

    if (_alphabet_ === alphabet) {
        return;
    }

    if (_alphabet_.length !== ORIGINAL.length) {
        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. You submitted ' + _alphabet_.length + ' characters: ' + _alphabet_);
    }

    var unique = _alphabet_.split('').filter(function(item, ind, arr){
       return ind !== arr.lastIndexOf(item);
    });

    if (unique.length) {
        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. These characters were not unique: ' + unique.join(', '));
    }

    alphabet = _alphabet_;
    reset();
}

function characters(_alphabet_) {
    setCharacters(_alphabet_);
    return alphabet;
}

function setSeed(seed) {
    randomFromSeed.seed(seed);
    if (previousSeed !== seed) {
        reset();
        previousSeed = seed;
    }
}

function shuffle() {
    if (!alphabet) {
        setCharacters(ORIGINAL);
    }

    var sourceArray = alphabet.split('');
    var targetArray = [];
    var r = randomFromSeed.nextValue();
    var characterIndex;

    while (sourceArray.length > 0) {
        r = randomFromSeed.nextValue();
        characterIndex = Math.floor(r * sourceArray.length);
        targetArray.push(sourceArray.splice(characterIndex, 1)[0]);
    }
    return targetArray.join('');
}

function getShuffled() {
    if (shuffled) {
        return shuffled;
    }
    shuffled = shuffle();
    return shuffled;
}

/**
 * lookup shuffled letter
 * @param index
 * @returns {string}
 */
function lookup(index) {
    var alphabetShuffled = getShuffled();
    return alphabetShuffled[index];
}

module.exports = {
    characters: characters,
    seed: setSeed,
    lookup: lookup,
    shuffled: getShuffled
};


/***/ }),
/* 3 */
/***/ (function(module, exports) {

function supported (versions) {
  return versions.map(function (i) {
    return i + '.x'
  }).join(', ')
}

/**
 * Logux error in logs synchronization.
 *
 * @param {BaseSync} sync The sync instance.
 * @param {string} type The error code.
 * @param {any} options The error option.
 * @param {boolean} received Was error received from remote node.
 *
 * @example
 * if (error.name === 'SyncError') {
 *   console.log('Server throws: ' + error.description)
 * }
 *
 * @extends Error
 * @class
 */
function SyncError (sync, type, options, received) {
  Error.call(this, type)

  /**
   * Always equal to `SyncError`. The best way to check error class.
   * @type {string}
   *
   * @example
   * if (error.name === 'SyncError') { }
   */
  this.name = 'SyncError'

  /**
   * The error code.
   * @type {string}
   *
   * @example
   * if (error.type === 'timeout') {
   *   fixNetwork()
   * }
   */
  this.type = type

  /**
   * Error options depends on error type.
   * @type {any}
   *
   * @example
   * if (error.type === 'timeout') {
   *   console.error('A timeout was reached (' + error.options + ' ms)')
   * }
   */
  this.options = options

  /**
   * Human-readable error description.
   * @type {string}
   *
   * @example
   * console.log('Server throws: ' + error.description)
   */
  this.description = SyncError.describe(type, options)

  /**
   * Current sync instance.
   * @type {BaseSync}
   *
   * @example
   * error.sync.connection.connected
   */
  this.sync = sync

  /**
   * Was error received from remote client.
   * @type {boolean}
   */
  this.received = !!received

  this.message = ''
  if (received) {
    if (this.sync.remoteNodeId) {
      this.message += this.sync.remoteNodeId + ' sent '
    } else {
      this.message += 'Logux received '
    }
    this.message += this.type + ' error'
    if (this.description !== this.type) {
      this.message += ' (' + this.description + ')'
    }
  } else {
    this.message = this.description
  }

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, SyncError)
  }
}

/**
 * Return a error description by it code.
 *
 * @param {string} type The error code.
 * @param {any} options The errors options depends on error code.
 *
 * @return {string} Human-readable error description.
 *
 * @example
 * errorMessage(msg) {
 *   console.log(SyncError.describe(msg[1], msg[2]))
 * }
 */
SyncError.describe = function describe (type, options) {
  if (type === 'timeout') {
    return 'A timeout was reached (' + options + 'ms)'
  } else if (type === 'wrong-format') {
    return 'Wrong message format in ' + options
  } else if (type === 'unknown-message') {
    return 'Unknown message `' + options + '` type'
  } else if (type === 'missed-auth') {
    return 'Start authentication before sending message ' + options
  } else if (type === 'wrong-protocol') {
    return 'Only ' + supported(options.supported) + ' Logux protocols ' +
           'are supported, but you use ' + options.used.join('.')
  } else if (type === 'wrong-subprotocol') {
    return 'Only ' + options.supported + ' application subprotocols are ' +
           'supported, but you use ' + options.used
  } else if (type === 'wrong-credentials') {
    return 'Wrong credentials'
  } else {
    return type
  }
}

SyncError.prototype = Error.prototype

module.exports = SyncError


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

var NanoEvents = __webpack_require__(0)

/**
 * Stores actions with time marks. Log is main idea in Logux.
 * In most end-user tools you will work with log and should know log API.
 *
 * @param {object} opts Options.
 * @param {Store} opts.store Store for log.
 * @param {string|number} opts.nodeId Unique current machine name.
 *
 * @example
 * import Log from 'logux-core/log'
 * const log = new Log({
 *   store: new MemoryStore(),
 *   nodeId: 'client:134'
 * })
 *
 * log.on('add', beeper)
 * log.add({ type: 'beep' })
 *
 * @class
 */
function Log (opts) {
  if (!opts) opts = { }

  if (typeof opts.nodeId === 'undefined') {
    throw new Error('Expected node ID for Logux')
  }
  /**
   * Unique node ID. It is used in action IDs.
   * @type {string|number}
   */
  this.nodeId = opts.nodeId

  this.lastTime = 0
  this.sequence = 0

  if (typeof opts.store !== 'object') {
    throw new Error('Expected Logux store to be a object')
  }
  this.store = opts.store

  this.emitter = new NanoEvents()
}

Log.prototype = {

  /**
   * Subscribe for log events. It implements nanoevents API. Supported events:
   *
   * * `before`: when somebody try to add action to log.
   *   It fires before ID check. The best place to add reason.
   * * `add`: when new action was added to log.
   * * `clean`: when action was cleaned from store.
   *
   * @param {"before"|"add"|"clean"} event The event name.
   * @param {listener} listener The listener function.
   *
   * @return {function} Unbind listener from event.
   *
   * @example
   * const unbind = log.on('add', (action, meta) => {
   *   if (action.type === 'beep') beep()
   * })
   * function disableBeeps () {
   *   unbind()
   * }
   */
  on: function (event, listener) {
    return this.emitter.on(event, listener)
  },

  /**
   * Add one-time listener for log events.
   * See {@link Log#on} for supported events.
   *
   * @param {"before"|"add"|"clean"} event The event name.
   * @param {listener} listener The listener function.
   *
   * @return {function} Unbind listener from event.
   *
   * @example
   * log.once('clean', () => {
   *   console.log('Autocleaning works')
   * })
   */
  once: function (event, listener) {
    return this.emitter.once(event, listener)
  },

  /**
   * Add action to log.
   *
   * It will set `id`, `time` (if they was missed) and `added` property
   * to `meta` and call all listeners.
   *
   * @param {Action} action The new action.
   * @param {Meta} [meta] Open structure for action metadata.
   * @param {ID} [meta.id] Unique action ID.
   * @param {number} [meta.time] Action created time.
   *                             Milliseconds since UNIX epoch.
   * @return {Promise} Promise with `meta` if action was added to log
   *                   or `false` if action was already in log
   *
   * @example
   * removeButton.addEventListener('click', () => {
   *   log.add({ type: 'users:remove', user: id })
   * })
   */
  add: function add (action, meta) {
    if (typeof action.type === 'undefined') {
      throw new Error('Expected "type" property in action')
    }

    if (!meta) meta = { }

    var newId = false
    if (typeof meta.id === 'undefined') {
      newId = true
      meta.id = this.generateId()
    }

    if (typeof meta.time === 'undefined') meta.time = meta.id[0]
    if (typeof meta.reasons === 'undefined') meta.reasons = []

    var emitter = this.emitter
    emitter.emit('before', action, meta)

    if (meta.reasons.length === 0 && newId) {
      emitter.emit('add', action, meta)
      emitter.emit('clean', action, meta)
      return Promise.resolve(meta)
    } else if (meta.reasons.length === 0) {
      return this.store.has(meta.id).then(function (already) {
        if (already) {
          return false
        } else {
          emitter.emit('add', action, meta)
          emitter.emit('clean', action, meta)
          return meta
        }
      })
    } else {
      return this.store.add(action, meta).then(function (addedMeta) {
        if (addedMeta === false) {
          return false
        } else {
          emitter.emit('add', action, addedMeta)
          return addedMeta
        }
      })
    }
  },

  /**
   * Generate next unique action ID.
   *
   * @return {ID} Unique action ID.
   *
   * @example
   * const id = log.generateId()
   */
  generateId: function generateId () {
    var now = Date.now()
    if (now <= this.lastTime) {
      now = this.lastTime
      this.sequence += 1
    } else {
      this.lastTime = now
      this.sequence = 0
    }
    return [now, this.nodeId, this.sequence]
  },

  /**
   * Iterates through all actions, from last to first.
   *
   * Return false from callback if you want to stop iteration.
   *
   * @param {object} [opts] Iterator options.
   * @param {'added'|'created'} [opts.order='created'] Sort entries by created
   *                                                   time or when they was
   *                                                   added to this log.
   * @param {iterator} callback Function will be executed on every action.
   *
   * @return {Promise} When iteration will be finished
   *                   by iterator or end of actions.
   *
   * @example
   * log.each((action, meta) => {
   *   if (compareTime(meta.id, lastBeep) <= 0) {
   *     return false;
   *   } else if (action.type === 'beep') {
   *     beep()
   *     lastBeep = meta.id
   *     return false;
   *   }
   * })
   */
  each: function each (opts, callback) {
    if (!callback) {
      callback = opts
      opts = { order: 'created' }
    }

    var store = this.store
    return new Promise(function (resolve) {
      function nextPage (get) {
        get().then(function (page) {
          var result
          for (var i = 0; i < page.entries.length; i++) {
            var entry = page.entries[i]
            result = callback(entry[0], entry[1])
            if (result === false) break
          }

          if (result === false || !page.next) {
            resolve()
          } else {
            nextPage(page.next)
          }
        })
      }

      nextPage(store.get.bind(store, opts))
    })
  },

  /**
   * Change action metadata. You will remove action by setting `reasons: []`.
   *
   * @param {ID} id Action ID.
   * @param {object} diff Object with values to change in action metadata.
   *
   * @return {Promise} Promise with `true` if metadata was changed
   *                   or `false` on unknown ID.
   *
   * @example
   * process.then(action.id, function () {
   *   log.changeMeta(action, { status: 'processed' })
   * })
   */
  changeMeta: function changeMeta (id, diff) {
    var key
    for (key in diff) {
      if (key === 'id' || key === 'added' || key === 'time') {
        throw new Error('Changing ' + key + ' is prohibbited in Logux')
      }
    }

    var emitter = this.emitter
    if (diff.reasons && diff.reasons.length === 0) {
      return this.store.remove(id).then(function (entry) {
        if (entry) {
          for (key in diff) entry[1][key] = diff[key]
          emitter.emit('clean', entry[0], entry[1])
        }
        return !!entry
      })
    } else {
      return this.store.changeMeta(id, diff)
    }
  },

  /**
   * Remove reason tag from action’s metadata and remove actions without reason
   * from log.
   *
   * @param {string} reason Reason’s name.
   * @param {object} [criteria] Actions criteria.
   * @param {number} [criteria.minAdded] Remove reason only for actions
   *                                     with bigger `added`.
   * @param {number} [criteria.maxAdded] Remove reason only for actions
   *                                     with lower `added`.
   *
   * @return {Promise} Promise when cleaning will be finished.
   *
   * @example
   * onSync(lastSent) {
   *   log.removeReason('unsynchronized', { maxAdded: lastSent })
   * }
   */
  removeReason: function removeReason (reason, criteria) {
    if (!criteria) criteria = { }
    var log = this
    return this.store.removeReason(reason, criteria, function (action, meta) {
      log.emitter.emit('clean', action, meta)
    })
  }
}

module.exports = Log

/**
 * @callback iterator
 * @param {Action} action Next action.
 * @param {Meta} meta Next action’s metadata.
 * @return {boolean} returning `false` will stop iteration.
 */


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var isFirstOlder = __webpack_require__(22)

function convert (list) {
  return list.map(function (i) {
    return [i[0], i[1]]
  })
}

function insert (store, entry) {
  store.lastAdded += 1
  entry[1].added = store.lastAdded
  store.added.unshift(entry)
  return Promise.resolve(entry[1])
}

function find (list, id) {
  var num = id[0]
  var cache = id.slice(1).join('\t')
  var m = 0
  var n = list.length - 1
  while (m <= n) {
    var i = (n + m) >> 1
    var entry = list[i]
    var otherNum = entry[1].id[0]
    if (otherNum > num) {
      m = i + 1
    } else if (otherNum < num) {
      n = i - 1
    } else if (entry[2] > cache) {
      m = i + 1
    } else if (entry[2] < cache) {
      n = i - 1
    } else {
      return i
    }
  }
  return -1
}

/**
 * Simple memory-based log store.
 *
 * It is good for tests, but not for server or client usage,
 * because it store all data in memory and will lose log on exit.
 *
 * @example
 * import { MemoryStore } from 'logux-core'
 *
 * var log = new Log({
 *   nodeId: 'server',
 *   store: new MemoryStore()
 * })
 *
 * @class
 * @extends Store
 */
function MemoryStore () {
  this.created = []
  this.added = []
  this.lastReceived = 0
  this.lastAdded = 0
  this.lastSent = 0
}

MemoryStore.prototype = {

  add: function add (action, meta) {
    var cache = meta.id.slice(1).join('\t')
    var entry = [action, meta, cache]

    var list = this.created
    for (var i = 0; i < list.length; i++) {
      var other = list[i]
      if (meta.id[0] === other[1].id[0] && cache === other[2]) {
        return Promise.resolve(false)
      } else if (isFirstOlder(other[1], meta) > 0) {
        list.splice(i, 0, entry)
        return insert(this, entry)
      }
    }

    list.push(entry)
    return insert(this, entry)
  },

  has: function (id) {
    return Promise.resolve(find(this.created, id) !== -1)
  },

  remove: function remove (id) {
    var created = find(this.created, id)
    if (created === -1) return Promise.resolve(false)

    var entry = [this.created[created][0], this.created[created][1]]
    this.created.splice(created, 1)

    var added = entry[1].added
    var m = 0
    var n = this.added.length - 1
    while (m <= n) {
      var i = (n + m) >> 1
      var otherAdded = this.added[i][1].added
      if (otherAdded > added) {
        m = i + 1
      } else if (otherAdded < added) {
        n = i - 1
      } else {
        this.added.splice(i, 1)
        break
      }
    }

    return Promise.resolve(entry)
  },

  get: function get (opts) {
    var entries
    if (opts.order === 'created') {
      entries = this.created
    } else {
      entries = this.added
    }
    return Promise.resolve({ entries: convert(entries) })
  },

  changeMeta: function changeMeta (id, diff) {
    var index = find(this.created, id)
    if (index === -1) {
      return Promise.resolve(false)
    } else {
      var meta = this.created[index][1]
      for (var key in diff) meta[key] = diff[key]
      return Promise.resolve(true)
    }
  },

  removeReason: function (reason, criteria, callback) {
    var removed = []
    this.created = this.created.filter(function (entry) {
      var meta = entry[1]
      var c = criteria

      if (meta.reasons.indexOf(reason) === -1) {
        return true
      }
      if (typeof c.minAdded !== 'undefined' && meta.added < c.minAdded) {
        return true
      }
      if (typeof c.maxAdded !== 'undefined' && meta.added > c.maxAdded) {
        return true
      }

      var reasons = meta.reasons
      reasons.splice(reasons.indexOf(reason), 1)
      if (meta.reasons.length === 0) {
        callback(entry[0], meta)
        removed.push(meta.added)
        return false
      } else {
        return true
      }
    })
    this.added = this.added.filter(function (entry) {
      return removed.indexOf(entry[1].added) === -1
    })
    return Promise.resolve()
  },

  getLastAdded: function getLastAdded () {
    return Promise.resolve(this.lastAdded)
  },

  getLastSynced: function getLastSynced () {
    return Promise.resolve({
      received: this.lastReceived,
      sent: this.lastSent
    })
  },

  setLastSynced: function setLastSynced (values) {
    if (typeof values.sent !== 'undefined') {
      this.lastSent = values.sent
    }
    if (typeof values.received !== 'undefined') {
      this.lastReceived = values.received
    }
    return Promise.resolve()
  }

}

module.exports = MemoryStore


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

var assign = __webpack_require__(1)

var BaseSync = __webpack_require__(7)

var DEFAULT_OPTIONS = {
  fixTime: true,
  timeout: 20000,
  ping: 5000
}

/**
 * Client node in synchronization pair.
 *
 * Instead of server node, it initializes synchronization
 * and sends connect message.
 *
 * @param {string|number} nodeId Unique current machine name.
 * @param {Log} log Logux log instance to be synchronized.
 * @param {Connection} connection Connection to remote node.
 * @param {object} [options] Synchronization options.
 * @param {object} [options.credentials] Client credentials.
 *                                       For example, access token.
 * @param {authCallback} [options.auth] Function to check server credentials.
 * @param {boolean} [options.fixTime=true] Detect difference between client
 *                                         and server and fix time
 *                                         in synchronized actions.
 * @param {number} [options.timeout=20000] Timeout in milliseconds
 *                                         to wait answer before disconnect.
 * @param {number} [options.ping=5000] Milliseconds since last message to test
 *                                     connection by sending ping.
 * @param {filter} [options.inFilter] Function to filter actions from server.
 *                                    Best place for permissions control.
 * @param {mapper} [options.inMap] Map function to change remote node’s action
 *                                 before put it to current log.
 * @param {filter} [options.outFilter] Filter function to select actions
 *                                     to synchronization.
 * @param {mapper} [options.outMap] Map function to change action
 *                                  before sending it to remote client.
 * @param {string} [options.subprotocol] Application subprotocol version
 *                                       in SemVer format.
 *
 * @example
 * import { ClientSync } from 'logux-sync'
 * const connection = new BrowserConnection(url)
 * const sync = new ClientSync(nodeId, log, connection)
 *
 * @extends BaseSync
 * @class
 */
function ClientSync (nodeId, log, connection, options) {
  options = assign({ }, DEFAULT_OPTIONS, options)
  BaseSync.call(this, nodeId, log, connection, options)
}

ClientSync.prototype = {

  onConnect: function onConnect () {
    if (!this.connected) {
      this.connected = true
      var sync = this
      this.initializing = this.initializing.then(function () {
        if (sync.connected) sync.sendConnect()
      })
    }
  }

}

ClientSync.prototype = assign({ }, BaseSync.prototype, ClientSync.prototype)

module.exports = ClientSync


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

var NanoEvents = __webpack_require__(0)
var assign = __webpack_require__(1)

var SyncError = __webpack_require__(3)

var connectMessages = __webpack_require__(24)
var errorMessages = __webpack_require__(25)
var pingMessages = __webpack_require__(26)
var syncMessages = __webpack_require__(27)

var validate = __webpack_require__(29)

var BEFORE_AUTH = ['connect', 'connected', 'error']

function syncMappedEvent (sync, action, meta) {
  if (sync.options.outMap) {
    sync.options.outMap(action, meta).then(function (changed) {
      sync.sendSync(changed[0], changed[1])
    })
  } else {
    sync.sendSync(action, meta)
  }
}

/**
 * Base methods for synchronization nodes. Client and server nodes
 * are based on this module.
 *
 * @param {string|number} nodeId Unique current machine name.
 * @param {Log} log Logux log instance to be synchronized.
 * @param {Connection} connection Connection to remote node.
 * @param {object} [options] Synchronization options.
 * @param {object} [options.credentials] Client credentials.
 *                                       For example, access token.
 * @param {authCallback} [options.auth] Function to check client credentials.
 * @param {boolean} [options.fixTime=false] Detect difference between client
 *                                          and server and fix time
 *                                          in synchronized actions.
 * @param {number} [options.timeout=0] Timeout in milliseconds to wait answer
 *                                     before disconnect.
 * @param {number} [options.ping=0] Milliseconds since last message to test
 *                                  connection by sending ping.
 * @param {filter} [options.inFilter] Function to filter actions
 *                                    from remote node. Best place
 *                                    for access control.
 * @param {mapper} [options.inMap] Map function to change remote node’s action
 *                                 before put it to current log.
 * @param {filter} [options.outFilter] Filter function to select actions
 *                                     to synchronization.
 * @param {mapper} [options.outMap] Map function to change action
 *                                  before sending it to remote client.
 * @param {string} [options.subprotocol] Application subprotocol version
 *                                       in SemVer format.
 *
 * @abstract
 * @class
 */
function BaseSync (nodeId, log, connection, options) {
  /**
   * Unique current machine name.
   * @type {string|number}
   *
   * @example
   * console.log(sync.localNodeId + ' is started')
   */
  this.localNodeId = nodeId
  /**
   * Log for synchronization.
   * @type {Log}
   */
  this.log = log
  /**
   * Connection used to communicate to remote node.
   * @type {Connection}
   */
  this.connection = connection
  /**
   * Synchronization options.
   * @type {object}
   */
  this.options = options || { }

  if (this.options.ping && !this.options.timeout) {
    throw new Error('You must set timeout option to use ping')
  }

  /**
   * Is synchronization in process.
   * @type {boolean}
   *
   * @example
   * sync.on('disconnect', () => {
   *   sync.connected //=> false
   * })
   */
  this.connected = false

  /**
   * Did we finish remote node authentication.
   * @type {boolean}
   */
  this.authenticated = false
  this.authenticating = false
  this.unauthenticated = []

  this.timeFix = 0
  this.syncing = 0
  this.received = { }

  /**
   * Latest current log `added` time, which was successfully synchronized.
   * It will be saves in log store.
   * @type {number}
   */
  this.lastSent = 0
  /**
   * Latest remote node’s log `added` time, which was successfully synchronized.
   * It will be saves in log store.
   * @type {number}
   */
  this.lastReceived = 0

  /**
   * Current synchronization state.
   *
   * * `disconnected`: no connection, but no new actions to synchronization.
   * * `wait`: new actions for synchronization but there is no connection.
   * * `connecting`: connection was established and we wait for node answer.
   * * `sending`: new actions was sent, waiting for answer.
   * * `synchronized`: all actions was synchronized and we keep connection.
   *
   * @type {"disconnected"|"wait"|"connecting"|"sending"|"synchronized"}
   *
   * @example
   * sync.on('state', () => {
   *   if (sync.state === 'wait' && sync.state === 'sending') {
   *     console.log('Do not close browser')
   *   }
   * })
   */
  this.state = 'disconnected'

  this.emitter = new NanoEvents()
  this.timeouts = []
  this.throwsError = true

  this.unbind = []
  var sync = this
  this.unbind.push(log.on('add', function (action, meta) {
    sync.onAdd(action, meta)
  }))
  this.unbind.push(connection.on('connecting', function () {
    sync.onConnecting()
  }))
  this.unbind.push(connection.on('connect', function () {
    sync.onConnect()
  }))
  this.unbind.push(connection.on('message', function (message) {
    sync.onMessage(message)
  }))
  this.unbind.push(connection.on('error', function (error) {
    if (error.message === 'Wrong message format') {
      sync.sendError(new SyncError(sync, 'wrong-format', error.received))
    } else {
      sync.error(error)
    }
    sync.connection.disconnect('error')
  }))
  this.unbind.push(connection.on('disconnect', function () {
    sync.onDisconnect()
  }))

  this.lastAddedCache = 0
  this.initializing = this.initialize()
}

BaseSync.prototype = {

  /**
   * Unique name of remote machine.
   * It is undefined until nodes handshake.
   *
   * @type {string|number|undefined}
   *
   * @example
   * console.log('Connected to ' + sync.remoteNodeId)
   */
  remoteNodeId: undefined,

  /**
   * Array with major and minor versions of used protocol.
   * @type {Version}
   *
   * @example
   * if (tool.sync.localProtocol[0] !== 1) {
   *   throw new Error('Unsupported Logux protocol')
   * }
   */
  localProtocol: [0, 1],

  /**
   * Array with major and minor versions of remote node protocol.
   * @type {Version|undefined}
   *
   * @example
   * if (sync.remoteProtocol[1] >= 5) {
   *   useNewAPI()
   * } else {
   *   useOldAPI()
   * }
   */
  remoteProtocol: undefined,

  /**
   * Remote node’s application subprotocol version in SemVer format.
   *
   * It is undefined until nodes handshake. If remote node will not send
   * on handshake its subprotocol, it will be set to `0.0.0`.
   *
   * @type {string|undefined}
   *
   * @example
   * if (semver.satisfies(sync.remoteSubprotocol, '>= 5.0.0') {
   *   useNewAPI()
   * } else {
   *   useOldAPI()
   * }
   */
  remoteSubprotocol: undefined,

  /**
   * Subscribe for synchronization events. It implements nanoevents API.
   * Supported events:
   *
   * * `state`: synchronization state was changed.
   * * `connect`: custom check before node authentication. You can throw
   *              a {@link SyncError} to send error to remote node.
   * * `error`: synchronization error was raised.
   * * `clientError`: when error was sent to remote node.
   *
   * @param {"state"|"connect"|"error"|"clientError"} event The event name.
   * @param {listener} listener The listener function.
   *
   * @return {function} Unbind listener from event.
   *
   * @example
   * sync.on('clientError', error => {
   *   logError(error)
   * })
   */
  on: function on (event, listener) {
    return this.emitter.on(event, listener)
  },

  /**
   * Add one-time listener for synchronization events.
   * See {@link BaseSync#on} for supported events.
   *
   * @param {"state"|"connect"|"error"|"clientError"} event The event name.
   * @param {listener} listener The listener function.
   *
   * @return {function} Unbind listener from event.
   *
   * @example
   * sync.once('clientError', () => {
   *   everythingFine = false
   * })
   */
  once: function once (event, listener) {
    return this.emitter.once(event, listener)
  },

  /**
   * Disable throwing a error on error message and create error listener.
   *
   * @param {errorListener} listener The listener function.
   *
   * @return {undefined}
   *
   * @example
   * sync.catch(error => {
   *   console.error(error)
   * })
   */
  catch: function (listener) {
    this.throwsError = false
    this.on('error', listener)
  },

  /**
   * Return Promise until {@link BaseSync#state} will be changed
   * to specific value.
   *
   * @param {string} state The expected synchronization state value.
   *
   * @return {Promise} Promise until specific state.
   *
   * @example
   * sync.waitFor('synchronized').then(() => {
   *   console.log('Everything is synchronized')
   * })
   */
  waitFor: function (state) {
    var sync = this
    return new Promise(function (resolve) {
      var unbind = sync.on('state', function () {
        if (sync.state === state) {
          unbind()
          resolve()
        }
      })
    })
  },

  /**
   * Shut down the connection and unsubscribe from log events.
   *
   * @return {undefined}
   *
   * @example
   * connection.on('disconnect', () => {
   *   server.destroy()
   * })
   */
  destroy: function destroy () {
    if (this.connection.destroy) {
      this.connection.destroy()
    } else if (this.connected) {
      this.connection.disconnect('destroy')
    }
    for (var i = 0; i < this.unbind.length; i++) {
      this.unbind[i]()
    }
  },

  send: function send (msg) {
    if (this.connected) {
      this.delayPing()
      this.connection.send(msg)
    } else {
      var json = JSON.stringify(msg)
      throw new Error('Could not send ' + json + ' to disconnected connection')
    }
  },

  onConnecting: function onConnecting () {
    this.setState('connecting')
  },

  onConnect: function onConnect () {
    this.delayPing()
    this.connected = true
  },

  onDisconnect: function onDisconnect () {
    this.endTimeout()
    if (this.pingTimeout) clearTimeout(this.pingTimeout)
    this.connected = false

    if (this.lastAddedCache > this.lastSent) {
      this.setState('wait')
    } else {
      this.setState('disconnected')
    }
  },

  onMessage: function onMessage (msg) {
    this.delayPing()

    if (!validate(this, msg)) return
    var name = msg[0]

    if (!this.authenticated && BEFORE_AUTH.indexOf(name) === -1) {
      if (this.authenticating) {
        this.unauthenticated.push(msg)
      } else {
        this.sendError(new SyncError(this, 'missed-auth', JSON.stringify(msg)))
      }
      return
    }

    var args = new Array(msg.length - 1)
    for (var i = 1; i < msg.length; i++) {
      args[i - 1] = msg[i]
    }
    this[name + 'Message'].apply(this, args)
  },

  onAdd: function onAdd (action, meta) {
    if (!this.connected) {
      this.setState('wait')
      return
    }
    if (this.lastAddedCache < meta.added) {
      this.lastAddedCache = meta.added
    }

    if (this.received[meta.id.join('\t')]) {
      delete this.received[meta.id.join('\t')]
      return
    }

    if (this.options.outFilter) {
      var sync = this
      this.options.outFilter(action, meta).then(function (result) {
        if (result) syncMappedEvent(sync, action, meta)
      })
    } else {
      syncMappedEvent(this, action, meta)
    }
  },

  syncError: function syncError (type, options, received) {
    var err = new SyncError(this, type, options, received)
    this.error(err)
  },

  error: function error (err) {
    this.emitter.emit('error', err)
    if (this.throwsError) {
      throw err
    }
  },

  setState: function setState (state) {
    if (this.state !== state) {
      this.state = state
      this.emitter.emit('state')
    }
  },

  startTimeout: function startTimeout () {
    if (!this.options.timeout) return

    var ms = this.options.timeout
    var sync = this
    var timeout = setTimeout(function () {
      if (sync.connected) sync.connection.disconnect('timeout')
      sync.syncError('timeout', ms)
    }, ms)

    this.timeouts.push(timeout)
  },

  endTimeout: function endTimeout () {
    if (this.timeouts.length > 0) {
      clearTimeout(this.timeouts.shift())
    }
  },

  delayPing: function delayPing () {
    if (!this.options.ping) return
    if (this.pingTimeout) clearTimeout(this.pingTimeout)

    var sync = this
    this.pingTimeout = setTimeout(function () {
      if (sync.connected) sync.sendPing()
    }, this.options.ping)
  },

  syncSince: function syncSince (lastSynced) {
    var data = []
    var sync = this
    this.log.each({ order: 'added' }, function (action, meta) {
      if (meta.added <= lastSynced) {
        return false
      } else {
        data.push(action, meta)
        return true
      }
    }).then(function () {
      if (!sync.connected) return
      if (data.length > 0) {
        sync.sendSync.apply(sync, data)
      } else {
        sync.setState('synchronized')
      }
    })
  },

  setLastSent: function setLastSent (value) {
    if (this.lastSent < value) this.lastSent = value
    this.log.store.setLastSynced({ sent: value })
  },

  setLastReceived: function setLastReceived (value) {
    if (this.lastReceived < value) this.lastReceived = value
    this.log.store.setLastSynced({ received: value })
  },

  now: function now () {
    return Date.now()
  },

  initialize: function initialize () {
    var sync = this
    return Promise.all([
      this.log.store.getLastSynced(),
      this.log.store.getLastAdded()
    ]).then(function (result) {
      sync.lastSent = result[0].sent
      sync.lastReceived = result[0].received
      sync.lastAddedCache = result[1]

      if (sync.lastAddedCache > sync.lastSent) sync.setState('wait')
      if (sync.connection.connected) sync.onConnect()
    })
  },

  sendDuilian: function sendDuilian (num) {
    var starts = Object.keys(DUILIANS)
    if (typeof num === 'undefined') {
      num = Math.floor(Math.random() * starts.length)
    }
    this.send(['duilian', starts[num]])
  },

  duilianMessage: function duilianMessage (line) {
    if (DUILIANS[line]) {
      this.send(['duilian', DUILIANS[line]])
    }
  }

}

var DUILIANS = {
  '世事洞眀皆學問': '人情練達即文章',
  '書山有路勤爲徑': '學海無涯苦作舟'
}

BaseSync.prototype = assign(BaseSync.prototype,
  errorMessages, connectMessages, pingMessages, syncMessages)

module.exports = BaseSync

/**
 * Logux protocol version.
 *
 * @typedef {number[]} Version
 */

/**
 * @callback errorListener
 * @param {string} error The error description.
 */

/**
 * @callback authCallback
 * @param {object} credentials Remote node credentials.
 * @param {string} nodeId Unique ID of remote sync instance.
 * @return {Promise} Promise with boolean value.
 */

/**
 * @callback filter
 * @param {Action} action New action from log.
 * @param {Meta} meta New action metadata.
 * @return {Promise} Promise with `true` if action should be synchronized
 *                   with remote log.
 */

/**
 * @callback mapper
 * @param {Action} action New action from log.
 * @param {Meta} meta New action metadata.
 * @return {Promise} Promise with array of changed action and changed metadata.
 */


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var randomByte = __webpack_require__(35);

function encode(lookup, number) {
    var loopCounter = 0;
    var done;

    var str = '';

    while (!done) {
        str = str + lookup( ( (number >> (4 * loopCounter)) & 0x0f ) | randomByte() );
        done = number < (Math.pow(16, loopCounter + 1 ) );
        loopCounter++;
    }
    return str;
}

module.exports = encode;


/***/ }),
/* 9 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 10 */
/***/ (function(module, exports) {

/**
 * Highlight tabs on synchronization errors.
 *
 * @param {Syncable|Client} client Observed Client instance
 *                                 or object with `sync` property.
 *
 * @return {Function} Unbind attention listener.
 *
 * @example
 * import attention from 'logux-status/attention'
 * attention(client)
 */
function attention (client) {
  var sync = client.sync

  var originTitle = false
  var unbind = []

  function tabListener () {
    if (!doc.hidden && originTitle) {
      doc.title = originTitle
      originTitle = false
    }
  }

  var doc = document

  if (typeof doc !== 'undefined' && typeof doc.hidden !== 'undefined') {
    unbind.push(sync.on('error', function (error) {
      if (error.type !== 'timeout' && !originTitle && doc.hidden) {
        originTitle = document.title
        document.title += '*'
      }
    }))

    document.addEventListener('visibilitychange', tabListener, false)
    unbind.push(function () {
      document.removeEventListener('visibilitychange', tabListener, false)
    })
  }

  return function () {
    for (var i = 0; i < unbind.length; i++) {
      unbind[i]()
    }
  }
}

module.exports = attention


/***/ }),
/* 11 */
/***/ (function(module, exports) {

/**
 * Show confirm popup, when user close tab with non-synchronized actions.
 *
 * @param {Syncable|Client} client Observed Client instance
 *                                 or object with `sync` property.
 * @param {String} [warning] The text of the warning.
 *
 * @return {Function} Unbind confirm listener.
 *
 * @example
 * import confirm from 'logux-status/confirm'
 * confirm(client, 'Post does not saved to server. Are you sure to leave?')
 */
function confirm (client, warning) {
  var sync = client.sync

  warning = warning || 'Some data was not saved to server. ' +
                       'Are you sure to leave?'

  function listen (e) {
    if (typeof e === 'undefined') e = window.event
    if (e) e.returnValue = warning
    return warning
  }

  return sync.on('state', function () {
    if (sync.state === 'wait' || sync.state === 'sending') {
      window.addEventListener('beforeunload', listen)
    } else {
      window.removeEventListener('beforeunload', listen)
    }
  })
}

module.exports = confirm


/***/ }),
/* 12 */
/***/ (function(module, exports) {

/**
 * Change favicon to show Logux synchronization status.
 *
 * @param {Syncable|Client} client Observed Client instance
 *                                 or object with `sync` property.
 * @param {object} [links] Set favicon links.
 * @param {string} [links.normal] Default favicon link.
 * @param {string} [links.offline] Offline favicon link.
 * @param {string} [links.error] Error favicon link.
 *
 * @return {Function} Unbind favicon listener.
 *
 * @example
 * import favicon from 'logux-status/favicon'
 * favicon(client, {
 *   normal: '/favicon.ico',
 *   offline: '/offline.ico',
 *   error: '/error.ico'
 * })
 */
function favicon (client, links) {
  links = links || {}
  var sync = client.sync

  var normal = links.normal
  var offline = links.offline
  var error = links.error

  var unbind = []
  var doc = document
  var fav = false
  var prevFav = false

  if (typeof doc !== 'undefined') {
    fav = doc.querySelector('link[rel~="icon"]')

    if (!fav) {
      fav = document.createElement('link')
      fav.rel = 'icon'
      fav.href = ''
      document.head.appendChild(fav)
    }

    unbind.push(sync.on('state', function () {
      if (sync.connected && normal && prevFav !== normal) {
        fav.href = prevFav = normal
      } else if (!sync.connected && offline &&
                 prevFav !== offline && prevFav !== error) {
        fav.href = prevFav = offline
      }
    }))

    unbind.push(sync.on('error', function (err) {
      if (err.type !== 'timeout' && error && prevFav !== error) {
        fav.href = prevFav = error
      }
    }))
  }

  return function () {
    for (var i = 0; i < unbind.length; i++) {
      unbind[i]()
    }
  }
}

module.exports = favicon


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

var browserSupportsLogStyles = __webpack_require__(20)

function style (string) {
  return '%c' + string + '%c'
}

function colorify (color, text, action, meta) {
  text = '%cLogux:%c ' + text
  if (!color) text = text.replace(/%c/g, '')

  var args = [text]
  var i

  if (color) {
    var styles = text.match(/%c[^%]+%c/g)
    for (i = 0; i < styles.length; i++) {
      if (i === 0) {
        args.push('color: #ffa200')
      } else {
        args.push('font-weight: bold')
      }
      args.push('')
    }
  }

  if (action && meta) {
    args.push(action)
    args.push(meta)
  }

  return args
}

/**
 * Display Logux events in browser console.
 *
 * @param {Syncable|Client} client Observed Client instance
 *                                 or object with `sync` property.
 * @param {object} [messages] Disable specific message types.
 * @param {boolean} [messages.state] Disable state messages.
 * @param {boolean} [messages.error] Disable error messages.
 * @param {boolean} [messages.add] Disable add messages.
 * @param {boolean} [messages.clean] Disable clean messages.
 * @param {boolean} [messages.color] Disable colors in logs.
 *
 * @return {Function} Unbind log listener.
 *
 * @example
 * import log from 'logux-status/log'
 * log(client, { add: false })
 */
function log (client, messages) {
  if (!messages) messages = { }
  var sync = client.sync

  var color = messages.color !== false && browserSupportsLogStyles()

  function showLog (text, action, meta) {
    console.log.apply(console, colorify(color, text, action, meta))
  }

  function showError (error) {
    var text = 'error: ' + error.description
    if (error.received) text = 'server sent ' + text
    console.error.apply(console, colorify(color, text))
  }

  var unbind = []
  var prevConnected = false

  if (messages.state !== false) {
    unbind.push(sync.on('state', function () {
      var postfix = ''

      if (sync.state === 'connecting' && sync.connection.url) {
        postfix = '. ' + style(sync.localNodeId) + ' is connecting to ' +
                  style(sync.connection.url) + '.'
      }

      if (sync.connected && !prevConnected) {
        postfix = '. Client was connected to ' + style(sync.remoteNodeId) + '.'
        prevConnected = true
      } else if (!sync.connected) {
        prevConnected = false
      }

      showLog('state was changed to ' + style(sync.state) + postfix)
    }))
  }

  if (messages.error !== false) {
    unbind.push(sync.on('error', function (error) {
      showError(error)
    }))
    unbind.push(sync.on('clientError', function (error) {
      showError(error)
    }))
  }

  if (messages.add !== false) {
    unbind.push(sync.log.on('add', function (action, meta) {
      var message = 'action ' + style(action.type) + ' was added'
      if (meta.id[1] !== sync.localNodeId) {
        message += ' by ' + style(meta.id[1])
      }
      showLog(message, action, meta)
    }))
  }

  if (messages.clean !== false) {
    unbind.push(sync.log.on('clean', function (action, meta) {
      var message = 'action ' + style(action.type) + ' was cleaned'
      showLog(message, action, meta)
    }))
  }

  return function () {
    for (var i = 0; i < unbind.length; i++) {
      unbind[i]()
    }
  }
}

module.exports = log


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var BrowserConnection = __webpack_require__(23)
var MemoryStore = __webpack_require__(5)
var ClientSync = __webpack_require__(6)
var Reconnect = __webpack_require__(28)
var shortid = __webpack_require__(30)
var Log = __webpack_require__(4)

var IndexedStore = __webpack_require__(21)

/**
 * Low-level browser API for Logux.
 *
 * @param {object} options Client options.
 * @param {string} options.url Server URL.
 * @param {string} options.subprotocol Client subprotocol version
 *                                     in SemVer format.
 * @param {number|string|false} options.userId User ID. Pass `false` on no user.
 * @param {any} [options.credentials] Client credentials for authentication.
 * @param {string} [options.prefix="logux"] Prefix for `IndexedDB` database
 *                                          to run multiple Logux instances
 *                                          on same web page.
 * @param {string|number} [options.nodeId] Unique client ID.
 *                                         Compacted UUID, by default.
 * @param {number} [options.timeout=20000] Timeout in milliseconds
 *                                         to break connection.
 * @param {number} [options.ping=10000] Milliseconds since last message to test
 *                                      connection by sending ping.
 * @param {Store} [options.store] Store to save log. Will be `IndexedStore`,
 *                                by default.
 * @param {number} [options.minDelay=1000] Minimum delay between reconnections.
 * @param {number} [options.maxDelay=5000] Maximum delay between reconnections.
 * @param {number} [options.attempts=Infinity] Maximum reconnection attempts.
 * @param {bool} [options.allowDangerousProtocol=false] Hide warning in case
 *                                                      using ws: in production.
 *
 * @example
 * token = document.querySelector('meta[name=token]')
 *
 * import Client from 'logux-client/client'
 * const app = new Client({
 *   credentials: token.content,
 *   subprotocol: '1.0.0',
 *   url: 'wss://example.com:1337'
 * })
 * app.sync.connection.connect()
 *
 * @class
 */
function Client (options) {
  /**
   * Client options.
   * @type {object}
   *
   * @example
   * console.log('Logux node ID is ' + app.options.nodeId)
   */
  this.options = options || { }

  if (typeof this.options.url === 'undefined') {
    throw new Error('Missed url option in Logux client')
  }
  if (typeof this.options.subprotocol === 'undefined') {
    throw new Error('Missed subprotocol option in Logux client')
  }
  if (typeof this.options.userId === 'undefined') {
    throw new Error('Missed userId option in Logux client. ' +
                    'Pass false if you have no users.')
  }

  if (typeof this.options.prefix === 'undefined') {
    this.options.prefix = 'logux'
  }

  var userId = this.options.userId
  if (userId) {
    userId += ':'
  } else {
    userId = ''
  }
  this.options.nodeId = userId + shortid.generate()

  var auth
  if (/^ws:\/\//.test(this.options.url) && !options.allowDangerousProtocol) {
    auth = function (cred) {
      if (typeof cred !== 'object' || cred.env !== 'development') {
        console.error(
          'Without SSL, old proxies can block WebSockets. ' +
          'Use WSS connection for Logux or set allowDangerousProtocol option.'
        )
        return Promise.resolve(false)
      }
      return Promise.resolve(true)
    }
  }

  var store = this.options.store
  if (!store) {
    if (global.indexedDB) {
      store = new IndexedStore(this.options.prefix)
    } else {
      store = new MemoryStore()
    }
  }

  /**
   * Client events log.
   * @type {Log}
   *
   * @example
   * app.log.keep(customKeeper)
   */
  this.log = new Log({ store: store, nodeId: this.options.nodeId })

  var ws = new BrowserConnection(this.options.url)
  var connection = new Reconnect(ws, {
    minDelay: this.options.minDelay,
    maxDelay: this.options.maxDelay,
    attempts: this.options.attempts
  })

  /**
   * Sync instance from `logux-sync` to synchronize logs.
   * @type {ClientSync}
   *
   * @example
   * if (client.sync.state === 'synchronized')
   */
  this.sync = new ClientSync(this.options.nodeId, this.log, connection, {
    credentials: this.options.credentials,
    subprotocol: this.options.subprotocol,
    timeout: this.options.timeout,
    ping: this.options.ping,
    auth: auth
  })

  this.sync.on('debug', function (type, stack) {
    if (type === 'error') {
      console.error('Error on Logux server:\n', stack)
    }
  })
}

module.exports = Client

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9)))

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

var NanoEvents = __webpack_require__(0)

function LocalConnection (pair, type) {
  this.connected = false
  this.emitter = new NanoEvents()
  this.type = type
  this.pair = pair
}

LocalConnection.prototype = {

  other: function other () {
    if (this.type === 'left') {
      return this.pair.right
    } else {
      return this.pair.left
    }
  },

  on: function on (event, listener) {
    return this.emitter.on(event, listener)
  },

  connect: function connect () {
    if (this.connected) {
      throw new Error('Connection already established')
    } else {
      var self = this
      return new Promise(function (resolve) {
        setTimeout(function () {
          self.other().connected = true
          self.connected = true
          self.other().emitter.emit('connect')
          self.emitter.emit('connect')
          resolve()
        }, 1)
      })
    }
  },

  disconnect: function disconnect (reason) {
    if (!this.connected) {
      throw new Error('Connection already finished')
    } else {
      this.connected = false
      this.emitter.emit('disconnect', reason)
      var self = this
      return new Promise(function (resolve) {
        setTimeout(function () {
          self.other().connected = false
          self.other().emitter.emit('disconnect')
          resolve()
        }, 1)
      })
    }
  },

  send: function send (message) {
    if (this.connected) {
      var self = this
      setTimeout(function () {
        self.other().emitter.emit('message', message)
      }, 1)
    } else {
      throw new Error('Connection should be started before sending a message')
    }
  }

}

/**
 * Two paired loopback connections.
 *
 * @example
 * import { LocalPair } from 'logux-sync'
 * const pair = new LocalPair()
 * const client = new ClientSync(pair.left)
 * const server = new ServerSync(pair.right)
 *
 * @class
 */
function LocalPair () {
  /**
   * First connection. Will be connected to {@link LocalPair#right} one
   * after {@link Connection#connect}.
   * @type {Connection}
   *
   * @example
   * new ClientSync(pair.left)
   */
  this.left = new LocalConnection(this, 'left')
  /**
   * Second connection. Will be connected to {@link LocalPair#left} one
   * after {@link Connection#connect}.
   * @type {Connection}
   *
   * @example
   * new ServerSync(pair.right)
   */
  this.right = new LocalConnection(this, 'right')
}

LocalPair.prototype = { }

module.exports = LocalPair


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var assign = __webpack_require__(1)

var BaseSync = __webpack_require__(7)

var DEFAULT_OPTIONS = {
  timeout: 20000,
  ping: 10000
}

/**
 * Server node in synchronization pair.
 *
 * Instead of client node, it doesn’t initialize synchronization
 * and destroy itself on disconnect.
 *
 * @param {string|number} nodeId Unique current machine name.
 * @param {Log} log Logux log instance to be synchronized.
 * @param {Connection} connection Connection to remote node.
 * @param {object} [options] Synchronization options.
 * @param {object} [options.credentials] Server credentials.
 *                                       For example, access token.
 * @param {authCallback} [options.auth] Function to check client credentials.
 * @param {number} [options.timeout=20000] Timeout in milliseconds
 *                                         to wait answer before disconnect.
 * @param {number} [options.ping=10000] Milliseconds since last message to test
 *                                      connection by sending ping.
 * @param {filter} [options.inFilter] Function to filter actions from client.
 *                                    Best place for permissions control.
 * @param {mapper} [options.inMap] Map function to change remote node’s action
 *                                 before put it to current log.
 * @param {filter} [options.outFilter] Filter function to select actions
 *                                     to synchronization.
 * @param {mapper} [options.outMap] Map function to change action
 *                                  before sending it to remote client.
 * @param {string} [options.subprotocol] Application subprotocol version
 *                                       in SemVer format.
 *
 * @example
 * import { ServerSync } from 'logux-sync'
 * startServer(ws => {
 *   const connection = new ServerConnection(ws)
 *   const sync = new ServerSync('server' + id, log, connection)
 * })
 *
 * @extends BaseSync
 * @class
 */
function ServerSync (nodeId, log, connection, options) {
  options = assign({ }, DEFAULT_OPTIONS, options)
  BaseSync.call(this, nodeId, log, connection, options)

  if (this.options.fixTime) {
    throw new Error(
      'Logux Server could not fix time. Set opts.fixTime for Client node.')
  }

  this.state = 'connecting'
}

ServerSync.prototype = {

  onConnect: function onConnect () {
    BaseSync.prototype.onConnect.call(this)
    this.startTimeout()
  },

  onDisconnect: function onDisconnect () {
    BaseSync.prototype.onDisconnect.call(this)
    this.destroy()
  },

  connectMessage: function connectMessage () {
    BaseSync.prototype.connectMessage.apply(this, arguments)
    this.endTimeout()
  },

  initialize: function initialize () {
    var sync = this
    return this.log.store.getLastAdded().then(function (added) {
      sync.lastAddedCache = added
      if (sync.connection.connected) sync.onConnect()
    })
  }

}

ServerSync.prototype = assign({ }, BaseSync.prototype, ServerSync.prototype)

module.exports = ServerSync


/***/ }),
/* 17 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),
/* 18 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),
/* 19 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),
/* 20 */
/***/ (function(module, exports) {

module.exports = browserSupportsLogStyles

function browserSupportsLogStyles () {
  // don’t run in non-browser environments
  if (typeof window === 'undefined' || typeof document === 'undefined') {
    return false
  }

  // http://stackoverflow.com/a/16459606/376773
  var isWebkit = 'WebkitAppearance' in document.documentElement.style
  // http://stackoverflow.com/a/398120/376773
  var isFirebug = window.console && (window.console.firebug || (window.console.exception && window.console.table)) && true
  // firefox >= v31? https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  var isFirefoxWithLogStyleSupport = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31

  return isWebkit || isFirebug || isFirefoxWithLogStyleSupport || false
}


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var VERSION = 1

function rejectify (request, reject) {
  request.onerror = function (e) {
    reject(e.target.error)
  }
}

function promisify (request) {
  return new Promise(function (resolve, reject) {
    rejectify(request, reject)
    request.onsuccess = function (e) {
      resolve(e.target.result)
    }
  })
}

function nextEntry (request) {
  return function (cursor) {
    if (cursor) {
      cursor.value.meta.added = cursor.value.added
      return {
        entries: [[cursor.value.action, cursor.value.meta]],
        next: function () {
          cursor.continue()
          return promisify(request).then(nextEntry(request))
        }
      }
    } else {
      return { entries: [] }
    }
  }
}

/**
 * `IndexedDB` store for Logux log.
 *
 * @param {string} [name="logux"] Database name to run multiple
 *                                Logux instances on same web page.
 *
 * @class
 * @extends Store
 *
 * @example
 * import IndexedStore from 'logux-client/indexed-store'
 * var log = new Log({ store: new IndexedStore(), nodeId })
 */
function IndexedStore (name) {
  this.name = name || 'logux'
}

IndexedStore.prototype = {

  init: function init () {
    if (this.initing) return this.initing

    var store = this
    var opening = indexedDB.open(this.name, VERSION)

    opening.onupgradeneeded = function (e) {
      var db = e.target.result

      var log = db.createObjectStore('log', {
        keyPath: 'added',
        autoIncrement: true
      })
      log.createIndex('id', 'id', { unique: true })
      log.createIndex('created', 'created', { unique: true })
      log.createIndex('reasons', 'reasons', { multiEntry: true })

      db.createObjectStore('extra', { keyPath: 'key' })
        .transaction.oncomplete = function () {
          db.transaction('extra', 'readwrite')
            .objectStore('extra')
            .add({ key: 'lastSynced', sent: 0, received: 0 })
        }
    }

    this.initing = promisify(opening).then(function (db) {
      store.db = db
      db.onversionchange = function () {
        store.db.close()
        if (global.document && global.document.reload) {
          global.document.reload()
        }
      }
      return store
    })

    return this.initing
  },

  get: function get (opts) {
    var request
    return this.init().then(function (store) {
      var log = store.os('log')
      if (opts.order === 'created') {
        request = log.index('created').openCursor(null, 'prev')
      } else {
        request = log.openCursor(null, 'prev')
      }
      return promisify(request).then(nextEntry(request))
    })
  },

  has: function has (id) {
    return this.init().then(function (store) {
      return promisify(store.os('log').index('id').get(id))
    }).then(function (result) {
      return !!result
    })
  },

  remove: function remove (id) {
    return this.init().then(function (store) {
      var log = store.os('log', 'write')
      return promisify(log.index('id').get(id)).then(function (entry) {
        if (!entry) {
          return false
        } else {
          return promisify(log.delete(entry.added)).then(function () {
            entry.meta.added = entry.added
            return [entry.action, entry.meta]
          })
        }
      })
    })
  },

  add: function add (action, meta) {
    var entry = {
      id: meta.id,
      meta: meta,
      time: meta.time,
      action: action,
      reasons: meta.reasons,
      created: meta.time + '\t' + meta.id.slice(1).join('\t')
    }

    return this.init().then(function (store) {
      var log = store.os('log', 'write')
      return promisify(log.index('id').get(meta.id)).then(function (exist) {
        if (exist) {
          return false
        } else {
          return promisify(log.add(entry)).then(function (added) {
            meta.added = added
            return meta
          })
        }
      })
    })
  },

  changeMeta: function changeMeta (id, diff) {
    return this.init().then(function (store) {
      var log = store.os('log', 'write')
      return promisify(log.index('id').get(id)).then(function (entry) {
        if (!entry) {
          return false
        } else {
          for (var key in diff) entry.meta[key] = diff[key]
          if (diff.reasons) entry.reasons = diff.reasons
          return promisify(log.put(entry)).then(function () {
            return true
          })
        }
      })
    })
  },

  removeReason: function removeReason (reason, criteria, callback) {
    return this.init().then(function (store) {
      var log = store.os('log', 'write')
      var request = log.index('reasons').openCursor(reason)
      return new Promise(function (resolve, reject) {
        rejectify(request, reject)
        request.onsuccess = function (e) {
          if (!e.target.result) {
            resolve()
            return
          }

          var entry = e.target.result.value
          var c = criteria
          if (typeof c.minAdded !== 'undefined' && entry.added < c.minAdded) {
            e.target.result.continue()
            return
          }
          if (typeof c.maxAdded !== 'undefined' && entry.added > c.maxAdded) {
            e.target.result.continue()
            return
          }

          var process
          if (entry.reasons.length === 1) {
            entry.meta.reasons = []
            entry.meta.added = entry.added
            callback(entry.action, entry.meta)
            process = log.delete(entry.added)
          } else {
            entry.reasons.splice(entry.reasons.indexOf(reason), 1)
            entry.meta.reasons = entry.reasons
            process = log.put(entry)
          }

          rejectify(process, reject)
          process.onsuccess = function () {
            e.target.result.continue()
          }
        }
      })
    })
  },

  getLastAdded: function getLastAdded () {
    return this.init().then(function (store) {
      return promisify(store.os('log').openCursor(null, 'prev'))
    }).then(function (cursor) {
      return cursor ? cursor.value.added : 0
    })
  },

  getLastSynced: function getLastSynced () {
    return this.init().then(function (store) {
      return promisify(store.os('extra').get('lastSynced'))
    }).then(function (data) {
      return { sent: data.sent, received: data.received }
    })
  },

  setLastSynced: function setLastSynced (values) {
    return this.init().then(function (store) {
      var extra = store.os('extra', 'write')
      return promisify(extra.get('lastSynced')).then(function (data) {
        if (typeof values.sent !== 'undefined') {
          data.sent = values.sent
        }
        if (typeof values.received !== 'undefined') {
          data.received = values.received
        }
        return promisify(extra.put(data))
      })
    })
  },

  os: function os (name, write) {
    var mode = write ? 'readwrite' : 'readonly'
    return this.db.transaction(name, mode).objectStore(name)
  },

  /**
   * Remove all database and data from `indexedDB`.
   *
   * @return {Promise} Promise for end of removing
   *
   * @example
   * afterEach(() => this.store.destroy())
   */
  destroy: function destroy () {
    return this.init().then(function (store) {
      store.db.close()
      return promisify(global.indexedDB.deleteDatabase(store.name))
    })
  }

}

module.exports = IndexedStore

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9)))

/***/ }),
/* 22 */
/***/ (function(module, exports) {

/**
 * Compare time, when log entries were created.
 *
 * It uses `meta.time` and `meta.id` to detect entries order.
 *
 * @param {Meta} firstMeta Some action’s metadata.
 * @param {Meta} secondMeta Other action’s metadata.
 *
 * @return {boolean} Is first action is older than second.
 *
 * @example
 * import { isFirstOlder } from 'logux-core'
 * if (isFirstOlder(lastBeep, meta) {
 *   beep(action)
 *   lastBeep = meta
 * }
 */
function isFirstOlder (firstMeta, secondMeta) {
  if (firstMeta && !secondMeta) {
    return false
  } else if (!firstMeta && secondMeta) {
    return true
  }

  if (firstMeta.time > secondMeta.time) {
    return false
  } else if (firstMeta.time < secondMeta.time) {
    return true
  }

  var firstStr = firstMeta.id.slice(1).join('\t')
  var secondStr = secondMeta.id.slice(1).join('\t')
  if (firstStr > secondStr) {
    return false
  } else if (firstStr < secondStr) {
    return true
  }

  return false
}

module.exports = isFirstOlder


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

var NanoEvents = __webpack_require__(0)

/**
 * Logux connection for browser WebSocket.
 *
 * @param {string} url WebSocket server URL.
 *
 * @example
 * import { BrowserConnection } from 'logux-websocket'
 *
 * const connection = new BrowserConnection('wss://logux.example.com/')
 * const sync = new ClientSync(nodeId, log, connection, opts)
 *
 * @class
 * @extends Connection
 */
function BrowserConnection (url) {
  this.connected = false
  this.emitter = new NanoEvents()

  this.url = url
}

BrowserConnection.prototype = {

  connect: function connect () {
    if (!window.WebSocket) {
      throw new Error('Browser has no WebSocket support')
    }

    this.emitter.emit('connecting')
    this.ws = new window.WebSocket(this.url)
    var self = this

    this.ws.onclose = function () {
      self.connected = false
      self.emitter.emit('disconnect')
    }

    this.ws.onmessage = function (event) {
      var data
      try {
        data = JSON.parse(event.data)
      } catch (e) {
        self.error(event.data)
        return
      }
      self.emitter.emit('message', data)
    }

    return new Promise(function (resolve) {
      self.ws.onopen = function () {
        self.connected = true
        self.emitter.emit('connect')
        resolve()
      }
    })
  },

  disconnect: function disconnect () {
    if (this.ws) {
      this.ws.close()
      this.ws.onclose()
      this.ws = undefined
    }
  },

  on: function on (event, listener) {
    return this.emitter.on(event, listener)
  },

  send: function send (message) {
    if (this.ws) {
      this.ws.send(JSON.stringify(message))
    } else {
      throw new Error('Start a connection before send a message')
    }
  },

  error: function error (message) {
    var err = new Error('Wrong message format')
    err.received = message
    this.emitter.emit('error', err)
  }

}

module.exports = BrowserConnection


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

var SyncError = __webpack_require__(3)

function auth (sync, nodeId, credentials, callback) {
  if (!sync.options.auth) {
    sync.authenticated = true
    callback()
    return
  }

  sync.authenticating = true
  sync.options.auth(credentials, nodeId).then(function (access) {
    if (access) {
      sync.authenticated = true
      sync.authenticating = false

      callback()
      for (var i = 0; i < sync.unauthenticated.length; i++) {
        sync.onMessage(sync.unauthenticated[i])
      }
      sync.unauthenticated = []
    } else {
      sync.sendError(new SyncError(sync, 'wrong-credentials'))
      sync.destroy()
    }
  })
}

function emitEvent (sync) {
  try {
    sync.emitter.emit('connect')
  } catch (e) {
    if (e.name === 'SyncError') {
      sync.sendError(e)
      return false
    } else {
      throw e
    }
  }
  return true
}

module.exports = {

  sendConnect: function sendConnect () {
    var message = [
      'connect',
      this.localProtocol,
      this.localNodeId,
      this.lastReceived
    ]

    var options = { }
    if (this.options.credentials) {
      options.credentials = this.options.credentials
    }
    if (this.options.subprotocol) {
      options.subprotocol = this.options.subprotocol
    }
    if (Object.keys(options).length > 0) message.push(options)

    if (this.options.fixTime) this.connectSended = this.now()
    this.startTimeout()
    this.send(message)
  },

  sendConnected: function sendConnected (start, end) {
    var message = [
      'connected',
      this.localProtocol,
      this.localNodeId,
      [start, end]
    ]

    var options = { }
    if (this.options.credentials) {
      options.credentials = this.options.credentials
    }
    if (this.options.subprotocol) {
      options.subprotocol = this.options.subprotocol
    }
    if (Object.keys(options).length > 0) message.push(options)

    this.send(message)
  },

  connectMessage: function connectMessage (ver, nodeId, synced, options) {
    var start = this.now()
    if (!options) options = { }

    this.remoteProtocol = ver
    this.remoteNodeId = nodeId

    var major = this.localProtocol[0]
    if (major !== ver[0]) {
      this.sendError(new SyncError(this, 'wrong-protocol', {
        supported: [major], used: ver
      }))
      this.destroy()
      return
    }

    this.remoteSubprotocol = options.subprotocol || '0.0.0'

    if (!emitEvent(this)) {
      this.destroy()
      return
    }

    var sync = this
    auth(this, nodeId, options.credentials, function () {
      sync.sendConnected(start, sync.now())
      sync.syncSince(synced)
    })
  },

  connectedMessage: function connectedMessage (ver, nodeId, time, options) {
    if (!options) options = { }

    this.endTimeout()
    this.remoteProtocol = ver
    this.remoteNodeId = nodeId

    if (this.options.fixTime) {
      var now = this.now()
      var authTime = time[1] - time[0]
      var roundTrip = now - this.connectSended - authTime
      this.timeFix = Math.floor(this.connectSended - time[0] + roundTrip / 2)
    }

    this.remoteSubprotocol = options.subprotocol || '0.0.0'

    if (!emitEvent(this)) {
      this.destroy()
      return
    }

    var sync = this
    auth(this, nodeId, options.credentials, function () {
      sync.syncSince(sync.lastSent)
    })
  }

}


/***/ }),
/* 25 */
/***/ (function(module, exports) {

module.exports = {

  sendError: function sendError (error) {
    var message = ['error', error.type]
    if (typeof error.options !== 'undefined') message.push(error.options)
    this.send(message)

    this.emitter.emit('clientError', error)
  },

  errorMessage: function errorMessage (type, options) {
    this.syncError(type, options, true)
  }

}


/***/ }),
/* 26 */
/***/ (function(module, exports) {

module.exports = {

  sendPing: function sendPing () {
    this.startTimeout()
    this.send(['ping', this.lastAddedCache])
    if (this.pingTimeout) clearTimeout(this.pingTimeout)
  },

  pingMessage: function pingMessage (synced) {
    this.setLastReceived(synced)
    this.send(['pong', this.lastAddedCache])
  },

  pongMessage: function pongMessage (synced) {
    this.setLastReceived(synced)
    this.endTimeout()
  }

}


/***/ }),
/* 27 */
/***/ (function(module, exports) {

module.exports = {

  sendSync: function sendSync () {
    this.startTimeout()

    var max = 0
    var data = []
    for (var i = 0; i < arguments.length - 1; i += 2) {
      var meta = arguments[i + 1]
      var time = meta.time
      if (this.timeFix) time = time - this.timeFix
      if (max < meta.added) max = meta.added
      data.push(arguments[i], { id: meta.id, time: time })
    }

    this.syncing += 1
    this.setState('sending')
    this.send(['sync', max].concat(data))
  },

  sendSynced: function sendSynced (added) {
    this.send(['synced', added])
  },

  syncMessage: function syncMessage (added) {
    var sync = this
    var promises = []

    for (var i = 1; i < arguments.length - 1; i += 2) {
      var action = arguments[i]
      var meta = arguments[i + 1]

      var process = Promise.resolve([action, meta])
      if (this.options.inFilter) {
        process = process.then(function (data) {
          return sync.options.inFilter(data[0], data[1])
            .then(function (result) {
              if (result) {
                return data
              } else {
                return false
              }
            })
        })
      }

      process.then(function (data) {
        if (!data) return false

        if (sync.timeFix) data[1].time = data[1].time + sync.timeFix
        if (sync.options.inMap) {
          return sync.options.inMap(data[0], data[1])
        } else {
          return data
        }
      }).then(function (changed) {
        if (!changed) return false
        sync.received[changed[1].id.join('\t')] = true
        return sync.log.add(changed[0], changed[1])
      })

      promises.push(process)
    }

    Promise.all(promises).then(function () {
      sync.setLastReceived(added)
      sync.sendSynced(added)
    })
  },

  syncedMessage: function syncedMessage (synced) {
    this.setLastSent(synced)
    if (this.syncing > 0) this.syncing -= 1
    if (this.syncing === 0) {
      this.endTimeout()
      this.setState('synchronized')
    }
  }

}


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

var assign = __webpack_require__(1)

var DEFAULT_OPTIONS = {
  minDelay: 1000,
  maxDelay: 5000,
  attempts: Infinity
}

var FATAL_ERRORS = ['wrong-protocol', 'wrong-subprotocol', 'wrong-credentials']

/**
 * Wrapper for {@link Connection} for reconnecting it on every disconnect.
 *
 * @param {Connection} connection The connection to be reconnectable.
 * @param {object} [options] Options.
 * @param {number} [options.minDelay=1000] Minimum delay between reconnecting.
 * @param {number} [options.maxDelay=5000] Maximum delay between reconnecting.
 * @param {number} [options.attempts=Infinity] Maximum reconnecting attempts.
 *
 * @example
 * import { Reconnect } from 'logux-sync'
 * const recon = new Reconnect(connection)
 * ClientHost(nodeId, log, recon, options)
 *
 * @class
 * @extends Connection
 */
function Reconnect (connection, options) {
  this.connection = connection
  this.options = assign({ }, DEFAULT_OPTIONS, options)

  /**
   * Should we reconnect connection on next connection break.
   * Next {@link Reconnect#connect} call will set to `true`.
   * @type {boolean}
   *
   * @example
   * function lastTry () {
   *   recon.reconnecting = false
   * }
   */
  this.reconnecting = connection.connected
  this.connecting = false
  this.attempts = 0

  this.unbind = []
  var self = this

  this.unbind.push(this.connection.on('message', function (msg) {
    if (msg[0] === 'error' && FATAL_ERRORS.indexOf(msg[1]) !== -1) {
      self.reconnecting = false
    }
  }))
  this.unbind.push(this.connection.on('connecting', function () {
    self.connecting = true
  }))
  this.unbind.push(this.connection.on('connect', function () {
    self.attempts = 0
    self.connecting = false
  }))
  this.unbind.push(this.connection.on('disconnect', function () {
    self.connecting = false
    if (self.reconnecting) self.reconnect()
  }))
  this.unbind.push(function () {
    clearTimeout(self.timer)
  })

  if (typeof document !== 'undefined' &&
      typeof document.hidden !== 'undefined') {
    var listener = this.visibilityChanged.bind(this)
    document.addEventListener('visibilitychange', listener, false)
    this.unbind.push(function () {
      document.removeEventListener('visibilitychange', listener, false)
    })
  }
}

Reconnect.prototype = {

  connect: function connect () {
    this.attempts += 1
    this.reconnecting = true
    return this.connection.connect()
  },

  disconnect: function disconnect (reason) {
    if (reason !== 'timeout') this.reconnecting = false
    return this.connection.disconnect(reason)
  },

  /**
   * Unbind all listeners and disconnect. Use it if you will not need
   * this class anymore.
   *
   * {@link BaseSync#destroy} will call this method instead
   * of {@link Reconnect#disconnect}.
   *
   * @return {undefined}
   */
  destroy: function destroy () {
    for (var i = 0; i < this.unbind.length; i++) {
      this.unbind[i]()
    }
    this.disconnect('destroy')
  },

  reconnect: function reconnect () {
    if (this.attempts > this.options.attempts - 1) {
      this.reconnecting = false
      this.attempts = 0
      return
    }

    var delay = this.nextDelay()
    var self = this
    this.timer = setTimeout(function () {
      if (self.reconnecting && !self.connecting && !self.connected) {
        self.connect()
      }
    }, delay)
  },

  send: function send () {
    return this.connection.send.apply(this.connection, arguments)
  },

  on: function on () {
    return this.connection.on.apply(this.connection, arguments)
  },

  nextDelay: function nextDelay () {
    var base = this.options.minDelay * Math.pow(2, this.attempts)
    var rand = Math.random()
    var deviation = Math.floor(rand * 0.5 * base)
    if (Math.floor(rand * 10) === 1) deviation = -deviation
    return Math.min(base + deviation, this.options.maxDelay) || 0
  },

  visibilityChanged: function visibilityChanged () {
    if (this.reconnecting && !this.connected && !this.connecting) {
      if (!document.hidden) this.connect()
    }
  }

}

Object.defineProperty(Reconnect.prototype, 'connected', {
  get: function () {
    return this.connection.connected
  }
})

module.exports = Reconnect


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

var SyncError = __webpack_require__(3)

function isNumber (value) {
  return typeof value === 'number'
}

function isString (value) {
  return typeof value === 'string'
}

function isObject (value) {
  return typeof value === 'object' && typeof value.length !== 'number'
}

function isArray (value) {
  return typeof value === 'object' && typeof value.length === 'number'
}

function isTwoNumbers (value) {
  return isArray(value) && value.length === 2 &&
    isNumber(value[0]) && isNumber(value[0])
}

function isNodeId (value) {
  return isString(value) || isNumber(value)
}

var validators = {

  connect: function connect (msg) {
    return isTwoNumbers(msg[1]) && isNodeId(msg[2]) && isNumber(msg[3]) &&
      (msg.length === 4 || msg.length === 5 && isObject(msg[4]))
  },

  connected: function connected (msg) {
    return isTwoNumbers(msg[1]) && isNodeId(msg[2]) && isTwoNumbers(msg[3]) &&
      (msg.length === 4 || msg.length === 5 && isObject(msg[4]))
  },

  ping: function ping (msg) {
    return msg.length === 2 && isNumber(msg[1])
  },

  pong: function pong (msg) {
    return msg.length === 2 && isNumber(msg[1])
  },

  sync: function sync (msg) {
    if (!isNumber(msg[1])) return false
    if (msg.length % 2 !== 0) return false

    for (var i = 2; i < msg.length; i++) {
      if (!isObject(msg[i])) return false
      if (i % 2 === 0 && !isString(msg[i].type)) return false
    }

    return true
  },

  synced: function synced (msg) {
    return msg.length === 2 && isNumber(msg[1])
  },

  error: function error (msg) {
    return (msg.length === 2 || msg.length === 3) && isString(msg[1])
  },

  duilian: function duilian (msg) {
    return (msg.length === 2) && isString(msg[1])
  }
}

function wrongFormat (sync, msg) {
  sync.sendError(new SyncError(sync, 'wrong-format', JSON.stringify(msg)))
  sync.connection.disconnect('error')
  return false
}

function validate (sync, msg) {
  if (!isArray(msg)) return wrongFormat(sync, msg)

  var name = msg[0]
  if (!isString(name)) return wrongFormat(sync, msg)

  var validator = validators[name]
  if (!validator || !sync[name + 'Message']) {
    sync.sendError(new SyncError(sync, 'unknown-message', name))
    sync.connection.disconnect('error')
    return false
  }

  if (!validator(msg)) {
    return wrongFormat(sync, msg)
  } else {
    return true
  }
}

module.exports = validate


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = __webpack_require__(33);


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var encode = __webpack_require__(8);
var alphabet = __webpack_require__(2);

// Ignore all milliseconds before a certain time to reduce the size of the date entropy without sacrificing uniqueness.
// This number should be updated every year or so to keep the generated id short.
// To regenerate `new Date() - 0` and bump the version. Always bump the version!
var REDUCE_TIME = 1459707606518;

// don't change unless we change the algos or REDUCE_TIME
// must be an integer and less than 16
var version = 6;

// Counter is used when shortid is called multiple times in one second.
var counter;

// Remember the last time shortid was called in case counter is needed.
var previousSeconds;

/**
 * Generate unique id
 * Returns string id
 */
function build(clusterWorkerId) {

    var str = '';

    var seconds = Math.floor((Date.now() - REDUCE_TIME) * 0.001);

    if (seconds === previousSeconds) {
        counter++;
    } else {
        counter = 0;
        previousSeconds = seconds;
    }

    str = str + encode(alphabet.lookup, version);
    str = str + encode(alphabet.lookup, clusterWorkerId);
    if (counter > 0) {
        str = str + encode(alphabet.lookup, counter);
    }
    str = str + encode(alphabet.lookup, seconds);

    return str;
}

module.exports = build;


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var alphabet = __webpack_require__(2);

/**
 * Decode the id to get the version and worker
 * Mainly for debugging and testing.
 * @param id - the shortid-generated id.
 */
function decode(id) {
    var characters = alphabet.shuffled();
    return {
        version: characters.indexOf(id.substr(0, 1)) & 0x0f,
        worker: characters.indexOf(id.substr(1, 1)) & 0x0f
    };
}

module.exports = decode;


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var alphabet = __webpack_require__(2);
var encode = __webpack_require__(8);
var decode = __webpack_require__(32);
var build = __webpack_require__(31);
var isValid = __webpack_require__(34);

// if you are using cluster or multiple servers use this to make each instance
// has a unique value for worker
// Note: I don't know if this is automatically set when using third
// party cluster solutions such as pm2.
var clusterWorkerId = __webpack_require__(37) || 0;

/**
 * Set the seed.
 * Highly recommended if you don't want people to try to figure out your id schema.
 * exposed as shortid.seed(int)
 * @param seed Integer value to seed the random alphabet.  ALWAYS USE THE SAME SEED or you might get overlaps.
 */
function seed(seedValue) {
    alphabet.seed(seedValue);
    return module.exports;
}

/**
 * Set the cluster worker or machine id
 * exposed as shortid.worker(int)
 * @param workerId worker must be positive integer.  Number less than 16 is recommended.
 * returns shortid module so it can be chained.
 */
function worker(workerId) {
    clusterWorkerId = workerId;
    return module.exports;
}

/**
 *
 * sets new characters to use in the alphabet
 * returns the shuffled alphabet
 */
function characters(newCharacters) {
    if (newCharacters !== undefined) {
        alphabet.characters(newCharacters);
    }

    return alphabet.shuffled();
}

/**
 * Generate unique id
 * Returns string id
 */
function generate() {
  return build(clusterWorkerId);
}

// Export all other functions as properties of the generate function
module.exports = generate;
module.exports.generate = generate;
module.exports.seed = seed;
module.exports.worker = worker;
module.exports.characters = characters;
module.exports.decode = decode;
module.exports.isValid = isValid;


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var alphabet = __webpack_require__(2);

function isShortId(id) {
    if (!id || typeof id !== 'string' || id.length < 6 ) {
        return false;
    }

    var characters = alphabet.characters();
    var len = id.length;
    for(var i = 0; i < len;i++) {
        if (characters.indexOf(id[i]) === -1) {
            return false;
        }
    }
    return true;
}

module.exports = isShortId;


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var crypto = typeof window === 'object' && (window.crypto || window.msCrypto); // IE 11 uses window.msCrypto

function randomByte() {
    if (!crypto || !crypto.getRandomValues) {
        return Math.floor(Math.random() * 256) & 0x30;
    }
    var dest = new Uint8Array(1);
    crypto.getRandomValues(dest);
    return dest[0] & 0x30;
}

module.exports = randomByte;


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Found this seed-based random generator somewhere
// Based on The Central Randomizer 1.3 (C) 1997 by Paul Houle (houle@msc.cornell.edu)

var seed = 1;

/**
 * return a random number based on a seed
 * @param seed
 * @returns {number}
 */
function getNextValue() {
    seed = (seed * 9301 + 49297) % 233280;
    return seed/(233280.0);
}

function setSeed(_seed_) {
    seed = _seed_;
}

module.exports = {
    nextValue: getNextValue,
    seed: setSeed
};


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = 0;


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

var LocalPair = __webpack_require__(15)
var ClientSync = __webpack_require__(6)
var ServerSync = __webpack_require__(16)
var MemoryStore = __webpack_require__(5)
var Log = __webpack_require__(4)
var Client = __webpack_require__(14)

// Logux Status features
var log = __webpack_require__(13)
var attention = __webpack_require__(10)
var confirm = __webpack_require__(11)
var favicon = __webpack_require__(12)

var faviconNormal = __webpack_require__(18)
var faviconOffline = __webpack_require__(19)
var faviconError = __webpack_require__(17)

// Create LocalPair instance
// to emulate connection
var pair = new LocalPair()

// Create Logux Client instance.
var client = new Client({
  // There are some required options
  // that used to create connection instance for Logux Client

  // It's not needed
  // because connection should be overrided by LocalPair
  subprotocol: null,
  url: null,
  userId: null
})

// Override Logux Client `sync` property
// to make Logux Client work with LocalPair
client.sync = new ClientSync('client', client.log, pair.left)

// Create Logux Log for ServerSync
var serverLog = new Log({ store: new MemoryStore(), nodeId: 'server' })
// Create ServerSync instance with LocalPair connection
new ServerSync('server', serverLog, pair.right)

// Apply Logux Status features
log(client)
attention(client)
confirm(client)
favicon(client, {
  normal: faviconNormal,
  offline: faviconOffline,
  error: faviconError
})

// Toggle connection
document.getElementById('toggle-connection').onchange = function (e) {
  if (e.target.checked) {
    client.sync.connection.connect()
  } else {
    client.sync.connection.disconnect()
  }
}

// Add action
document.getElementById('add-action').onclick = function () {
  client.log.add(
    { type: 'test' },
    { reasons: ['test'] }
  )
}

// Clean actions
document.getElementById('clean-actions').onclick = function () {
  client.log.removeReason('test')
}

// Send client error after 3sec
document.getElementById('send-client-error').onclick = function () {
  setTimeout(function () {
    client.sync.syncError('wrong-format')
  }, 3000)
}

// Send server error after 3sec
document.getElementById('send-server-error').onclick = function () {
  setTimeout(function () {
    pair.right.send(['error', 'wrong-format'])
  }, 3000)
}


/***/ })
/******/ ]);</script></body>
</html>